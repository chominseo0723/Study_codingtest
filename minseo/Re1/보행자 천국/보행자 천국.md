# [level 3] 보행자 천국 - 1832 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/1832?language=java) 

### 성능 요약

메모리: 107 MB, 시간: 81.61 ms

### 구분

코딩테스트 연습 > 2017 카카오코드 예선

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 03월 30일 17:35:54

### 문제 설명

<h2>보행자 천국</h2>

<p>카카오내비 개발자인 제이지는 시내 중심가의 경로 탐색 알고리즘 개발 업무를 담당하고 있다. 최근 들어 보행자가 자유롭고 편리하게 걸을 수 있도록 보행자 중심의 교통 체계가 도입되면서 도심의 일부 구역은 자동차 통행이 금지되고, 일부 교차로에서는 보행자 안전을 위해 좌회전이나 우회전이 금지되기도 했다. 복잡해진 도로 환경으로 인해 기존의 경로 탐색 알고리즘을 보완해야 할 필요가 생겼다.</p>

<p>도시 중심가의 지도는 <code>m × n</code> 크기의 격자 모양 배열 <code>city_map</code>으로 주어진다. 자동차는 오른쪽 또는 아래 방향으로 한 칸씩 이동 가능하다.</p>

<p><code>city_map[i][j]</code>에는 도로의 상황을 나타내는 값이 저장되어 있다.</p>

<ul>
<li><code>0</code>인 경우에는 자동차가 자유롭게 지나갈 수 있다.</li>
<li><code>1</code>인 경우에는 자동차 통행이 금지되어 지나갈 수 없다.</li>
<li><code>2</code>인 경우는 보행자 안전을 위해 좌회전이나 우회전이 금지된다. (왼쪽에서 오던 차는 오른쪽으로만, 위에서 오던 차는 아래쪽으로만 진행 가능하다)</li>
</ul>

<p><img src="http://t1.kakaocdn.net/codefestival/oneway500.png" title="One Way Map" alt="example map"></p>

<p>도시의 도로 상태가 입력으로 주어졌을 때, 왼쪽 위의 출발점에서 오른쪽 아래 도착점까지 자동차로 이동 가능한 전체 가능한 경로 수를 출력하는 프로그램을 작성하라. 이때 가능한 경로의 수는 컴퓨터가 표현할 수 있는 정수의 범위를 넘어설 수 있으므로, 가능한 경로 수를 <code>20170805</code>로 나눈 나머지 값을 출력하라.</p>

<h3>입력 형식</h3>

<p>입력은 도시의 크기를 나타내는 <code>m</code>과 <code>n</code>, 그리고 지도를 나타내는 2차원 배열 <code>city_map</code>으로 주어진다. 제한조건은 아래와 같다.</p>

<ul>
<li><code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>city_map</code>의 크기는 <code>m × n</code>이다.</li>
<li>배열의 모든 원소의 값은 <code>0</code>, <code>1</code>, <code>2</code> 중 하나이다.</li>
<li>출발점의 좌표는 <code>(0, 0)</code>, 도착점의 좌표는 <code>(m - 1, n - 1)</code>이다.</li>
<li>출발점과 도착점의 <code>city_map[i][j]</code> 값은 <code>0</code>이다.</li>
</ul>

<h3>출력 형식</h3>

<p>출발점에서 도착점까지 이동 가능한 전체 경로의 수를 <code>20170805</code>로 나눈 나머지를 리턴한다.</p>

<h3>예제 입출력</h3>
<table class="table">
        <thead><tr>
<th>m</th>
<th>n</th>
<th>city_map</th>
<th>answer</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>3</td>
<td>[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>[[0, 2, 0, 0, 0, 2], [0, 0, 2, 0, 1, 0], [1, 0, 0, 2, 2, 0]]</td>
<td>2</td>
</tr>
</tbody>
      </table>
<h3>예제에 대한 설명</h3>

<p>첫 번째 예제는 모든 도로가 제한 없이 통행 가능한 경우로, 가능한 경우의 수는 6가지이다.<br>
두 번째 예제는 문제 설명에 있는 그림의 경우이다. 가능한 경우의 수는 빨간 실선과 노란 점선 2가지뿐이다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges
>
> ## 아이디어
> 풀리지않아 다른 사람의 풀이를 참고하였다. DP 를 활용하여 문제를 풀었는데 DP 란 무엇인가

### DP란?

- Dynamic Programming (동적 계획법)으로 하나의 큰 문제를 작은 문제로 나누어 해결하는 기법을 의미한다. 기본적으로 DP는 작은 문제로 나누고 작은 문제 결과를 재사용해서 원하는 결과를 도출하는 과정이다. 다음 문제에서  DP 를 어떤식으로 사용하였을까

우선 3차원 배열을 구성한다 

이유는?  이전에 이동했던 방향 정보를 별도로 관리하기 위해서이다

첫 번째 차원은 크기가 2이며 (i, j)위치에 이쪽 방향으로 도착한 경로 수 저장하는 것 하나 ( dp[0][i][j]), (i,j) 위치에 왼쪽 방향으로 도착한 경로의 수를 저장하는 것 하나 (dp[1][i][j]) 총 두 개의 크기를 구성한다

두번째 차원은 도시의 크기가 mxn 이지만 경계 처리를 쉽게 하기위해 한 칸씩 여유 공간을 두기 위해 [m+1][n+1] 로 정해준다

현재 무지? 의 상태는 출발점에 이미 있는 상태이므로 첫 시작을 dp[0][0][0] = 1 로 설정해준다

도시의 행, 열을 순회한 후 (i,j)에서 가능한 다음 이동 방향에 따른 경로를 누적하기 위해 전체 격자를 순회한다

만약 if(cityMap[i][j] == 0) 이라면 현재(i,j)가 일반 도로로 어떤 방향으로 이동해도 제한이 없다 

 else if(cityMap[i][j] == 2) 일 경우 좌/우 회전이 제한된 도로이므로 위에서 아래로 내려오던 경로만 아래로 계속 갈 수 있고 왼쪽에서 오른쪽으로 오던 경로만 오른쪽으로 갈 수 있다.

모든 순회를 끝냈다면 
도착점 `(m-1, n-1)`에 위쪽에서 내려온 경로의 수
와 도착점 `(m-1, n-1)`에 왼쪽에서 온 경로의 수를 합한 후 MOD로 나눈 나머지를 반환한다
> 
